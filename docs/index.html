<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>sanisizer: Sanitize sizes to avoid integer overflow</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">sanisizer
   </div>
   <div id="projectbrief">Sanitize sizes to avoid integer overflow</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="doc-content">
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Sanitize sizes to avoid integer overflow </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__2github_2workspace_2README"></a></p>
<p><img src="https://github.com/LTLA/sanisizer/actions/workflows/run-tests.yaml/badge.svg" alt="Unit tests" style="pointer-events: none;" class="inline"/> <img src="https://github.com/LTLA/sanisizer/actions/workflows/doxygenate.yaml/badge.svg" alt="Documentation" style="pointer-events: none;" class="inline"/> <a href="https://codecov.io/gh/LTLA/sanisizer"><img src="https://codecov.io/gh/LTLA/sanisizer/branch/master/graph/badge.svg?token=UIfGJvpZTi" alt="Codecov" style="pointer-events: none;" class="inline"/></a></p>
<h1><a class="anchor" id="autotoc_md1"></a>
Overview</h1>
<p>Both <code>new</code> and many constructors of STL containers accept an integer that specifies the size of the array/container. Any user-supplied value will be implicitly cast to the expected type of the argument - <code>std::size_t</code> for <code>new</code>, and some <code>size_type</code> for container constructors. In some cases, the implicit cast could silently overflow, resulting in a smaller array/container than expected. This library provides a few methods for sanitizing size values so that any overflow results in an error.</p>
<h1><a class="anchor" id="autotoc_md2"></a>
Casting</h1>
<p>Given an integer, we use <code>sanizer::cast()</code> to convert it to the expected type of the size for our array/container. This will throw an error if the value of our integer would cause an overflow.</p>
<div class="fragment"><div class="line"><span class="keywordtype">long</span> <span class="keywordtype">long</span> new_size = 12345;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Casting it avoids potential for overflow in constructor.</span></div>
<div class="line">std::vector&lt;double&gt; my_container;</div>
<div class="line">my_container.resize(<a class="code hl_function" href="namespacesanisizer.html#aed4423ffa6beced95cee29c155e494d2">sanisizer::cast</a>&lt;<span class="keyword">decltype</span>(my_container.size())&gt;(new_size));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Same for new, which expects a `std::size_t`.</span></div>
<div class="line"><span class="keyword">auto</span> ptr = <span class="keyword">new</span> <span class="keywordtype">double</span>[<a class="code hl_function" href="namespacesanisizer.html#aed4423ffa6beced95cee29c155e494d2">sanisizer::cast&lt;std::size_t&gt;</a>(new_size)];</div>
<div class="ttc" id="anamespacesanisizer_html_aed4423ffa6beced95cee29c155e494d2"><div class="ttname"><a href="namespacesanisizer.html#aed4423ffa6beced95cee29c155e494d2">sanisizer::cast</a></div><div class="ttdeci">Size_ cast(Input_ x)</div><div class="ttdef"><b>Definition</b> cast.hpp:46</div></div>
</div><!-- fragment --><p>We could also use <code><a class="el" href="namespacesanisizer.html#a7ece7999b7f4228f9721ef6c6a4a8cf2">sanisizer::create()</a></code>, which creates a new container instance with less of the type-deducation boilerplate:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> my_container2 = <a class="code hl_function" href="namespacesanisizer.html#a7ece7999b7f4228f9721ef6c6a4a8cf2">sanisizer::create&lt;std::vector&lt;double&gt;</a> &gt;(new_size);</div>
<div class="ttc" id="anamespacesanisizer_html_a7ece7999b7f4228f9721ef6c6a4a8cf2"><div class="ttname"><a href="namespacesanisizer.html#a7ece7999b7f4228f9721ef6c6a4a8cf2">sanisizer::create</a></div><div class="ttdeci">Container_ create(Input_ x, Args_ &amp;&amp;... args)</div><div class="ttdef"><b>Definition</b> cast.hpp:71</div></div>
</div><!-- fragment --><p>See the <a href="https://ltla.github.io/sanisizer">reference documentation</a> for more details.</p>
<h1><a class="anchor" id="autotoc_md3"></a>
Capping</h1>
<p>A related problem is to cap a value at the maximum of its type, typically when defining defaults for function arguments or class members. This avoids compile-time overflow (and the associated compiler warnings) and ensures that a sane value is used. For example, for data member defaults:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Options {</div>
<div class="line">    <span class="comment">// size_t is only guaranteed to hold up to 65535, so this will be the</span></div>
<div class="line">    <span class="comment">// cap if it can&#39;t faithfully hold our intended value of 100000.</span></div>
<div class="line">    std::size_t some_buffer_size = <a class="code hl_function" href="namespacesanisizer.html#a2e8f089e1c84d1189156e427de867d72">sanisizer::cap&lt;std::size_t&gt;</a>(100000);</div>
<div class="line">};</div>
<div class="ttc" id="anamespacesanisizer_html_a2e8f089e1c84d1189156e427de867d72"><div class="ttname"><a href="namespacesanisizer.html#a2e8f089e1c84d1189156e427de867d72">sanisizer::cap</a></div><div class="ttdeci">constexpr Size_ cap(Input_ x)</div><div class="ttdef"><b>Definition</b> cap.hpp:27</div></div>
</div><!-- fragment --><p>We can also use this inside function arguments:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> do_something(<span class="keywordtype">long</span> num_chunks = <a class="code hl_function" href="namespacesanisizer.html#a2e8f089e1c84d1189156e427de867d72">sanisizer::cap&lt;long&gt;</a>(10000000000)) {</div>
<div class="line">    <span class="comment">// Ditto for other integer types, which are only guaranteed to hold</span></div>
<div class="line">    <span class="comment">// up to a certain size - for long, this is at least 32 bits.</span></div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md4"></a>
Arithmetic</h1>
<p>Sometimes, we need to perform some arithmetic to determine the size of our array/container. For example, if we are creating an array that is the concatenation of smaller arrays, we would need to add the sizes of the latter. This summation needs to be checked for overflow using the <code>sum()</code> functions.</p>
<div class="fragment"><div class="line">std::vector&lt;long long&gt; individual_sizes{ 123, 456, 789 };</div>
<div class="line">std::size_t combined_size = 0; </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> is : individual_sizes) {</div>
<div class="line">    combined_size = <a class="code hl_function" href="namespacesanisizer.html#a89bb3c2d0ba52e16b6edcea1b45a754e">sanisizer::sum&lt;std::size_t&gt;</a>(combined_size, is);</div>
<div class="line">}</div>
<div class="ttc" id="anamespacesanisizer_html_a89bb3c2d0ba52e16b6edcea1b45a754e"><div class="ttname"><a href="namespacesanisizer.html#a89bb3c2d0ba52e16b6edcea1b45a754e">sanisizer::sum</a></div><div class="ttdeci">Size_ sum(Left_ left, Right_ right)</div><div class="ttdef"><b>Definition</b> arithmetic.hpp:50</div></div>
</div><!-- fragment --><p>When allocating contiguous memory for a high-dimensional array, we need to compute the product of the dimension extents. Again, this calculation can be done safely by using the <code>product()</code> functions to check for overflow.</p>
<div class="fragment"><div class="line">std::vector&lt;long long&gt; dimensions{ 123, 456, 789 };</div>
<div class="line">std::size_t combined_size = 1;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> is : individual_sizes) {</div>
<div class="line">    combined_size = <a class="code hl_function" href="namespacesanisizer.html#a45ebf64ffe61405e2ec5930008cb93e6">sanisizer::product&lt;std::size_t&gt;</a>(combined_size, is);</div>
<div class="line">}</div>
<div class="ttc" id="anamespacesanisizer_html_a45ebf64ffe61405e2ec5930008cb93e6"><div class="ttname"><a href="namespacesanisizer.html#a45ebf64ffe61405e2ec5930008cb93e6">sanisizer::product</a></div><div class="ttdeci">Size_ product(Left_ left, Right_ right)</div><div class="ttdef"><b>Definition</b> arithmetic.hpp:120</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md5"></a>
N-dimensional offsets</h1>
<p>Consider an N-dimensional array of dimensions <code>(d1, d2, ..., dN)</code> that is flattened and stored contiguously in memory. Let the first dimension be the fastest changing, then the second, and so on. If we want to access element <code>(x1, x2, ..., xN)</code>, we would compute the offset:</p>
<div class="fragment"><div class="line"><span class="comment">// For N = 3:</span></div>
<div class="line">x1 + d1 * (x2 + d2 * (x3));</div>
</div><!-- fragment --><p>If <code>x1</code>, <code>d1</code>, <code>x2</code>, etc. are of a smaller type than the array/container's size, the intermediate sums and products could overflow, even if the final offset itself would be representable by the array/container size type. To avoid this, we provide the <code>nd_offset()</code> function, which casts all inputs to the size type before performing calculations.</p>
<div class="fragment"><div class="line"><span class="comment">// Same calculation as above</span></div>
<div class="line"><a class="code hl_function" href="namespacesanisizer.html#ac9d066c34f8184cfaf21686d0427df68">sanisizer::nd_offset&lt;std::size_t&gt;</a>(x1, d1, x2, d2, x3);</div>
<div class="ttc" id="anamespacesanisizer_html_ac9d066c34f8184cfaf21686d0427df68"><div class="ttname"><a href="namespacesanisizer.html#ac9d066c34f8184cfaf21686d0427df68">sanisizer::nd_offset</a></div><div class="ttdeci">Size_ nd_offset(First_ x1, First_ extent1, Second_ x2, Remaining_... remaining)</div><div class="ttdef"><b>Definition</b> nd_offset.hpp:55</div></div>
</div><!-- fragment --><p>The idea is to use <code>nd_offset()</code> within tight loops - say, for accessing the 10-th column of a row-major matrix:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> c = 10;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> r = 0; r &lt; NR; ++r) {</div>
<div class="line">    <span class="comment">// Do something with the matrix element at (r, c)</span></div>
<div class="line">    <span class="keyword">auto</span> elmt = matrix[<a class="code hl_function" href="namespacesanisizer.html#ac9d066c34f8184cfaf21686d0427df68">sanisizer::nd_offset&lt;std::size_t&gt;</a>(c, NC, r)];</div>
<div class="line">}</div>
</div><!-- fragment --><p>(One might think that it would be better to compute an initial offset outside of the loop and just add <code>NC</code> in each loop iteration to avoid the multiplication. However, modern compilers - well, Clang and GCC, at least - will optimize out the multiplication so there is no performance penalty in practice. The above approach is easier to reason about and is more amenable to vectorization as there are no dependencies in the loop body. Importantly, it avoids overflow from adding <code>NC</code> in the final iteration, which could be undefined behavior if the size type is signed.)</p>
<h1><a class="anchor" id="autotoc_md6"></a>
Building projects</h1>
<h2><a class="anchor" id="autotoc_md7"></a>
CMake with <code>FetchContent</code></h2>
<p>If you're using CMake, you just need to add something like this to your <code>CMakeLists.txt</code>:</p>
<div class="fragment"><div class="line">include(FetchContent)</div>
<div class="line"> </div>
<div class="line">FetchContent_Declare(</div>
<div class="line">  sanisizer</div>
<div class="line">  GIT_REPOSITORY https://github.com/LTLA/sanisizer</div>
<div class="line">  GIT_TAG master # replace with a pinned version</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">FetchContent_MakeAvailable(sanisizer)</div>
</div><!-- fragment --><p>Then you can link to <b>sanisizer</b> to make the headers available during compilation:</p>
<div class="fragment"><div class="line"># For executables:</div>
<div class="line">target_link_libraries(myexe sanisizer)</div>
<div class="line"> </div>
<div class="line"># For libaries</div>
<div class="line">target_link_libraries(mylib INTERFACE sanisizer)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md8"></a>
CMake with <code>find_package()</code></h2>
<p>You can install the library by cloning a suitable version of this repository and running the following commands:</p>
<div class="fragment"><div class="line">mkdir build &amp;&amp; cd build</div>
<div class="line">cmake .. -DNCLIST_TESTS=OFF</div>
<div class="line">cmake --build . --target install</div>
</div><!-- fragment --><p>Then you can use <code>find_package()</code> as usual:</p>
<div class="fragment"><div class="line">find_package(ltla_sanisizer CONFIG REQUIRED)</div>
<div class="line">target_link_libraries(mylib INTERFACE ltla::sanisizer)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md9"></a>
Manual</h2>
<p>If you're not using CMake, the simple approach is to just copy the files in the <code>include/</code> subdirectory - either directly or with Git submodules - and include their path during compilation with, e.g., GCC's <code>-I</code>. </p>
</div></div><!-- PageDoc -->
<a href="doxygen_crawl.html"></a>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
